# ==========================================================================
# Project:   Spade - CommonJS Runtime
# Copyright: Â©2010 Strobe Inc. All rights reserved.
# License:   Licened under MIT license (see LICENSE)
# ==========================================================================

require 'json'

module Spade::Runtime
  BOOT_PATH = File.dirname(Spade::JSPATH)

  module Bundle
    class << self

      def update(rootdir, opts ={})

        verbose = opts[:verbose]
        spade_path = File.join(rootdir, Spade::SPADE_DIR)
        FileUtils.rm_r(spade_path) if File.exists? spade_path

        FileUtils.mkdir_p spade_path
        FileUtils.mkdir_p File.join(spade_path, 'packages')

        FileUtils.ln_s BOOT_PATH, File.join(spade_path, 'boot')

        installed = []
        package_dirs = []

        # In reverse order of precedence
        package_dirs << File.join(LibGems.dir, 'gems') if defined?(Spade::Packager)
        package_dirs += %w[vendor/cache vendor/packages packages].map{|p| File.join(rootdir, p.split('/')) }

        for package_dir in package_dirs
          Dir.glob(File.join(package_dir, '*')).each do |path|
            json_file = File.join(path, 'package.json')
            next unless File.exists?(json_file)

            # How would this happen?
            next if installed.include? path
            installed << path

            json = JSON.load File.read(json_file)
            package_name = json['name']
            package_version = json['version']

            local = path.index(rootdir) == 0

            # Use relative paths if embedded
            old_path = if local
              # Figure out how many levels deep the spade_path is in the project
              levels = spade_path.sub(rootdir, '').split(File::SEPARATOR).reject{|p| p.empty? }.count + 1
              # Build relative path
              File.join(['..'] * levels, path.sub(rootdir, ''))
            else
              path
            end

            new_path = File.join(spade_path, 'packages', package_name)

            FileUtils.ln_s old_path, new_path, :force => true

            puts "Installing #{local ? "local" : "remote"} package #{package_name}" if verbose
          end
        end

        File.open(File.join(rootdir, 'spade-boot.js'), 'w+') do |fp|
          fp.write gen_spade_boot(rootdir, opts)
        end
        puts "Wrote spade-boot.js" if verbose


      end

      def gen_spade_boot(rootdir, opts={})
        verbose = opts[:verbose]
        spade_path = File.join(rootdir, Spade::SPADE_DIR, 'packages', '*')
        known_packages = Dir.glob(spade_path).map do |path|
          package_name = File.basename path
          info = JSON.load File.read(File.join(path, 'package.json'))
          info["sync"] = true
          info["root"] = "#{Spade::SPADE_DIR}/packages/#{package_name}"
          info["files"] = package_file_list(path)
          info
        end

        if File.exists? File.join(rootdir, 'package.json')
          info = JSON.load File.read(File.join(rootdir, 'package.json'))
        else
          info = { 
            "name" => File.basename(rootdir), 
            "directories" => { "lib" => "lib" } 
          }
        end

        info["root"] = '.'
        info["sync"] = true
        info["files"] = package_file_list('.')

        packages = resolve_dependencies(info, known_packages)

%[// GENERATED: #{Time.now.to_s}
// This file is automatically generated by spade.  To update run 
// 'spade update'. To use this file, reference it in your HTML file.  Base 
// sure that your base URL is to the top level directory containing all of 
// your files.

/*globals spade */
//@ begin boot
(function() {
  // load spade itself
  var script = document.createElement('script');
  script.src = "#{Spade::SPADE_DIR}/boot/spade.js";
  script.onload = function() {

    // Register remaining packages with spade
#{packages.map{|p| %[spade.register("#{p["name"]}", #{JSON.pretty_generate(p)});\n] } * "\n"}

    // find the main module to run
    var main = null;
    var scripts = document.scripts || document.getElementsByTagName("script"),
        len = scripts.length;
    for(var idx=0;!main && idx<len;idx++) {
      main = scripts[idx].getAttribute('data-require');
    }
    scripts = null; // avoid memory leaks in IE

    if (main) spade.ready(function() { spade.require(main); });
  };

  var head = document.head || document.body || document;
  head.appendChild(script);

  script = head = null; // avoid memory leaks in IE
})();
//@ end boot
]

      end

      private

        def package_file_list(path)
          get_all_files(path).map{|p| p.sub(path+File::SEPARATOR, '') } - %w(package.json spade-boot.js)
        end

        # Supports recursive, be careful
        def get_all_files(path)
          Dir.glob(File.join(path, '**', '*')).
            map{|p| File.symlink?(p) ? get_all_files(p) : p }.
            flatten.
            reject{|p| File.extname(p).empty? }
        end

        def resolve_dependencies(package, available)
          # TODO: Should available be a hash to speed lookup?
          if package["dependencies"]
            # TODO: Check version numbers
            dependencies = package["dependencies"].keys
            packages = available.select{|p| dependencies.include?(p["name"]) }.
                                 map{|p| resolve_dependencies(p, available) }.
                                 flatten
            (packages << package).uniq
          else
            [package]
          end
        end

    end

  end
end
